<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="eventHubOut_connection_help" xml:space="preserve">
    <value>包含你的事件中心连接字符串的应用设置名称。连接字符串必须具有“发送”权限。</value>
  </data>
  <data name="eventHubOut_connection_label" xml:space="preserve">
    <value>事件中心连接</value>
  </data>
  <data name="eventHubOut_displayName" xml:space="preserve">
    <value>Azure 事件中心</value>
  </data>
  <data name="eventHubOut_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="eventHubOut_name_label" xml:space="preserve">
    <value>事件参数名称</value>
  </data>
  <data name="eventHubOut_path_errorText" xml:space="preserve">
    <value>事件中心名称必须以字母或数字开头和结尾，并且只能包含字母、数字、连字符、句点和下划线。名称必须介于 1 到 50 个字符之间。</value>
  </data>
  <data name="eventHubOut_path_help" xml:space="preserve">
    <value>这是将接收事件的事件中心的名称。</value>
  </data>
  <data name="eventHubOut_path_label" xml:space="preserve">
    <value>事件中心名称</value>
  </data>
  <data name="eventHubTrigger_connection_help" xml:space="preserve">
    <value>包含你的事件中心连接字符串的应用设置名称。连接字符串必须具有“接收”权限。</value>
  </data>
  <data name="eventHubTrigger_connection_label" xml:space="preserve">
    <value>事件中心连接</value>
  </data>
  <data name="eventHubTrigger_consumerGroup_help" xml:space="preserve">
    <value>从中接收事件的事件中心使用者组</value>
  </data>
  <data name="eventHubTrigger_consumerGroup_label" xml:space="preserve">
    <value>事件中心使用者组</value>
  </data>
  <data name="eventHubTrigger_displayName" xml:space="preserve">
    <value>Azure 事件中心</value>
  </data>
  <data name="eventHubTrigger_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此触发器的名称</value>
  </data>
  <data name="eventHubTrigger_name_label" xml:space="preserve">
    <value>事件参数名称</value>
  </data>
  <data name="eventHubTrigger_path_errorText" xml:space="preserve">
    <value>事件中心名称必须以字母或数字开头和结尾，并且只能包含字母、数字、连字符、句点和下划线。名称必须介于 1 到 50 个字符之间。</value>
  </data>
  <data name="eventHubTrigger_path_help" xml:space="preserve">
    <value>从中进行触发的事件中心的名称</value>
  </data>
  <data name="eventHubTrigger_path_label" xml:space="preserve">
    <value>事件中心名称</value>
  </data>
  <data name="queueOut_displayName" xml:space="preserve">
    <value>Azure 队列存储</value>
  </data>
  <data name="queueOut_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="queueOut_name_label" xml:space="preserve">
    <value>消息参数名称</value>
  </data>
  <data name="queueOut_queueName_errorText" xml:space="preserve">
    <value>队列名称必须以字母或数字开头和结尾，并且只能包含小写字母、数字和连字符。名称长度必须为 3 到 63 个字符。</value>
  </data>
  <data name="queueOut_queueName_label" xml:space="preserve">
    <value>队列名称</value>
  </data>
  <data name="queueOut_queueName_help" xml:space="preserve">
    <value>这是将向其发送消息的队列。如果队列尚不存在，将会在指定的存储帐户中为你创建一个队列。</value>
  </data>
  <data name="temp_category_core" xml:space="preserve">
    <value>核心</value>
  </data>
  <data name="temp_category_dataProcessing" xml:space="preserve">
    <value>数据处理</value>
  </data>
  <data name="temp_timerTrigger_CSharp_desc" xml:space="preserve">
    <value>将按指定计划运行的 C# 函数</value>
  </data>
  <data name="temp_timerTrigger_CSharp_name" xml:space="preserve">
    <value>TimerTrigger - C#</value>
  </data>
  <data name="timerTrigger_displayName" xml:space="preserve">
    <value>计时器</value>
  </data>
  <data name="timerTrigger_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此触发器的名称</value>
  </data>
  <data name="timerTrigger_name_label" xml:space="preserve">
    <value>时间戳参数名称</value>
  </data>
  <data name="timerTrigger_schedule_help" xml:space="preserve">
    <value>输入格式为“{second} {minute} {hour} {day} {month} {day of week}”的 cron 表达式来指定计划。请查看以下文档了解相关示例。</value>
  </data>
  <data name="timerTrigger_schedule_label" xml:space="preserve">
    <value>计划</value>
  </data>
  <data name="variables_apiHubTableConnectionHelp" xml:space="preserve">
    <value>包含外部表连接的应用设置的名称。</value>
  </data>
  <data name="variables_apiHubTableConnectionLabel" xml:space="preserve">
    <value>外部表连接</value>
  </data>
  <data name="variables_apiHubTableDataSetHelp" xml:space="preserve">
    <value>要绑定到的数据集的名称。如果绑定到表或实体，请保留为默认。</value>
  </data>
  <data name="variables_apiHubTableDataSetLabel" xml:space="preserve">
    <value>数据集名称</value>
  </data>
  <data name="variables_apiHubTableEntityHelp" xml:space="preserve">
    <value>要绑定到的实体的 ID 。如果绑定到数据集或表，请留空。</value>
  </data>
  <data name="variables_apiHubTableEntityLabel" xml:space="preserve">
    <value>实体 ID</value>
  </data>
  <data name="variables_apiHubTableHelp" xml:space="preserve">
    <value>要绑定到的表的名称。如果绑定到数据集或实体，请留空。</value>
  </data>
  <data name="variables_apiHubTableNameLabel" xml:space="preserve">
    <value>表名称</value>
  </data>
  <data name="variables_appSettingsHelp" xml:space="preserve">
    <value>这是存储帐户的连接字符串。</value>
  </data>
  <data name="variables_parameterName" xml:space="preserve">
    <value>参数名称必须为包含任意字符数的字母数字字符串，且不能以数字开头。</value>
  </data>
  <data name="variables_paramNameInputHelp" xml:space="preserve">
    <value>这是代码中用于输入绑定绑定到的参数的名称。</value>
  </data>
  <data name="variables_paramNameOutputHelp" xml:space="preserve">
    <value>这是代码中用于输出绑定绑定到的参数的名称。</value>
  </data>
  <data name="variables_selectConnection" xml:space="preserve">
    <value>单击“选择”以选择连接</value>
  </data>
  <data name="variables_storageConnStringLabel" xml:space="preserve">
    <value>存储帐户连接</value>
  </data>
  <data name="variables_paramNameLabel" xml:space="preserve">
    <value>参数名称</value>
  </data>
  <data name="temp_category_all" xml:space="preserve">
    <value>全部</value>
  </data>
  <data name="temp_category_api" xml:space="preserve">
    <value>API 和 Webhook</value>
  </data>
  <data name="temp_category_experimental" xml:space="preserve">
    <value>实验性</value>
  </data>
  <data name="temp_category_samples" xml:space="preserve">
    <value>示例</value>
  </data>
  <data name="blobOut_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="blobOut_name_label" xml:space="preserve">
    <value>Blob 参数名称</value>
  </data>
  <data name="queueTrigger_queueName_help" xml:space="preserve">
    <value>将从中读取消息的队列的名称</value>
  </data>
  <data name="queueTrigger_name_label" xml:space="preserve">
    <value>消息参数名称</value>
  </data>
  <data name="queueTrigger_queueName_errorText" xml:space="preserve">
    <value>队列名称必须以字母或数字开头和结尾，并且只能包含小写字母、数字和连字符。名称长度必须为 3 到 63 个字符。</value>
  </data>
  <data name="queueTrigger_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此触发器的名称</value>
  </data>
  <data name="queueTrigger_queueName_label" xml:space="preserve">
    <value>队列名称</value>
  </data>
  <data name="blobOut_path_help" xml:space="preserve">
    <value>这是将写入 blob 的存储帐户中的路径。</value>
  </data>
  <data name="blobOut_path_errorText" xml:space="preserve">
    <value>你的 blob 路径必须是包含 3 到 63 个字符的容器名称，且后跟一个包含 1 到 1,024 个字符的 blob 名称。该 blob 名称可以是任何字符组合且最多可包含 254 个用正斜杠(/)分隔的路径段。</value>
  </data>
  <data name="blobOut_path_label" xml:space="preserve">
    <value>路径</value>
  </data>
  <data name="blobIn_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="blobIn_name_label" xml:space="preserve">
    <value>Blob 参数名称</value>
  </data>
  <data name="blobIn_path_help" xml:space="preserve">
    <value>这是将从中读取 blob 的存储帐户中的路径。</value>
  </data>
  <data name="blobIn_path_label" xml:space="preserve">
    <value>路径</value>
  </data>
  <data name="blobIn_patherrorText" xml:space="preserve">
    <value>你的 blob 路径必须是包含 3 到 63 个字符的容器名称，且后跟一个包含 1 到 1,024 个字符的 blob 名称。该 blob 名称可以是任何字符组合且最多可包含 254 个用正斜杠(/)分隔的路径段。</value>
  </data>
  <data name="blobTrigger_name_label" xml:space="preserve">
    <value>Blob 参数名称</value>
  </data>
  <data name="blobTrigger_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此触发器的名称</value>
  </data>
  <data name="blobTrigger_path_label" xml:space="preserve">
    <value>路径</value>
  </data>
  <data name="blobTrigger_path_help" xml:space="preserve">
    <value>这是触发器将会监视的存储帐户中的路径。</value>
  </data>
  <data name="blobTrigger_path_errorText" xml:space="preserve">
    <value>你的 blob 路径必须是包含 3 到 63 个字符的容器名称，且后跟一个包含 1 到 1,024 个字符的 blob 名称。该 blob 名称可以是任何字符组合且最多可包含 254 个用正斜杠(/)分隔的路径段。</value>
  </data>
  <data name="apiHubFileIn_name_label" xml:space="preserve">
    <value>文件参数名称</value>
  </data>
  <data name="apiHubFileIn_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="apiHubFileIn_path_label" xml:space="preserve">
    <value>路径</value>
  </data>
  <data name="apiHubFileIn_path_help" xml:space="preserve">
    <value>输入文件路径</value>
  </data>
  <data name="apiHubFileIn_connection_label" xml:space="preserve">
    <value>外部文件连接</value>
  </data>
  <data name="apiHubFileIn_connection_help" xml:space="preserve">
    <value>包含你的外部文件连接字符串的应用设置名称</value>
  </data>
  <data name="apiHubFileTrigger_name_label" xml:space="preserve">
    <value>文件参数名称</value>
  </data>
  <data name="apiHubFileTrigger_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此触发器的名称</value>
  </data>
  <data name="apiHubFileTrigger_path_label" xml:space="preserve">
    <value>路径</value>
  </data>
  <data name="apiHubFileTrigger_path_help" xml:space="preserve">
    <value>要在其中触发的路径。此路径必须存在。</value>
  </data>
  <data name="apiHubFileTrigger_connection_label" xml:space="preserve">
    <value>外部文件连接</value>
  </data>
  <data name="apiHubFileTrigger_connection_help" xml:space="preserve">
    <value>包含你的外部文件连接字符串的应用设置名称</value>
  </data>
  <data name="apiHubTableIn_displayName" xml:space="preserve">
    <value>外部表(实验)</value>
  </data>
  <data name="apiHubTableOut_displayName" xml:space="preserve">
    <value>外部表(实验)</value>
  </data>
  <data name="httpTrigger_displayName" xml:space="preserve">
    <value>HTTP</value>
  </data>
  <data name="httpTrigger_name_label" xml:space="preserve">
    <value>请求参数名称</value>
  </data>
  <data name="httpTrigger_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此触发器的名称</value>
  </data>
  <data name="httpTrigger_webHookType_label" xml:space="preserve">
    <value>Webhook 类型</value>
  </data>
  <data name="httpTrigger_webHookType_help" xml:space="preserve">
    <value>Webhook 使服务可以轻易地相互调用。</value>
  </data>
  <data name="httpTrigger_authLevel_label" xml:space="preserve">
    <value>身份验证级别</value>
  </data>
  <data name="httpTrigger_methods_label" xml:space="preserve">
    <value>选定的 HTTP 方法</value>
  </data>
  <data name="httpTrigger_methods_help" xml:space="preserve">
    <value>这些是此函数会响应的唯一方法。</value>
  </data>
  <data name="httpTrigger_methodRule_label" xml:space="preserve">
    <value>允许的 HTTP 方法</value>
  </data>
  <data name="httpTrigger_route_label" xml:space="preserve">
    <value>路由模板</value>
  </data>
  <data name="httpTrigger_route_help" xml:space="preserve">
    <value>通过路由模板设置，可更改会触发此函数的 URI。值应为相对路径。路径段可能被视为参数，将其以大括号括起。例如: customer/{customerId}</value>
  </data>
  <data name="httpTrigger_methodRule_help" xml:space="preserve">
    <value>HttpTrigger 可响应任何 HTTP 方法。若想要限制对特定方法的支持，请选择“所选方法”选项。</value>
  </data>
  <data name="httpTrigger_mode_label" xml:space="preserve">
    <value>模式</value>
  </data>
  <data name="httpTrigger_mode_help" xml:space="preserve">
    <value>这是触发器的模式。“标准”是指请求将为无任何其他语义的标准 HTTP。"Webhook" 指请求将根据指定的 Webhook 类型进行处理。</value>
  </data>
  <data name="apiHubFileIn_displayName" xml:space="preserve">
    <value>外部文件(预览)</value>
  </data>
  <data name="apiHubFileTrigger_displayName" xml:space="preserve">
    <value>外部文件(预览)</value>
  </data>
  <data name="blobIn_displayName" xml:space="preserve">
    <value>Azure Blob 存储</value>
  </data>
  <data name="blobOut_displayName" xml:space="preserve">
    <value>Azure Blob 存储</value>
  </data>
  <data name="blobTrigger_displayName" xml:space="preserve">
    <value>Azure Blob 存储</value>
  </data>
  <data name="documentDBIn_collectionName_help" xml:space="preserve">
    <value>这是将从中读取数据的数据库的内部集合的名称。</value>
  </data>
  <data name="documentDBIn_collectionName_label" xml:space="preserve">
    <value>集合名称</value>
  </data>
  <data name="documentDBIn_connection_help" xml:space="preserve">
    <value>包含你的 DocumentDB 连接字符串的应用设置名称</value>
  </data>
  <data name="documentDBIn_connection_label" xml:space="preserve">
    <value>DocumentDB 帐户连接</value>
  </data>
  <data name="documentDBIn_databaseName_help" xml:space="preserve">
    <value>将从中读取数据的 DocumentDB 帐户内的数据库的名称。</value>
  </data>
  <data name="documentDBIn_databaseName_label" xml:space="preserve">
    <value>数据库名称</value>
  </data>
  <data name="documentDBIn_displayName" xml:space="preserve">
    <value>Azure DocumentDB</value>
  </data>
  <data name="documentDBIn_id_help" xml:space="preserve">
    <value>这是将被读取的文档的 ID。如果既未指定 SQL 查询也未指定 ID，则返回集合中的所有文档。</value>
  </data>
  <data name="documentDBIn_id_label" xml:space="preserve">
    <value>文档 ID (可选)</value>
  </data>
  <data name="documentDBIn_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="documentDBIn_name_label" xml:space="preserve">
    <value>文档参数名称</value>
  </data>
  <data name="documentDBOut_collectionName_help" xml:space="preserve">
    <value>这是将写入数据的数据库的内部集合的名称。</value>
  </data>
  <data name="documentDBOut_collectionName_label" xml:space="preserve">
    <value>集合名称</value>
  </data>
  <data name="documentDBOut_connection_help" xml:space="preserve">
    <value>包含你的 DocumentDB 连接字符串的应用设置名称</value>
  </data>
  <data name="documentDBOut_connection_label" xml:space="preserve">
    <value>DocumentDB 帐户连接</value>
  </data>
  <data name="documentDBOut_createIfNotExists_help" xml:space="preserve">
    <value>如果为 true，你的数据库和集合将会自动创建。</value>
  </data>
  <data name="documentDBOut_createIfNotExists_label" xml:space="preserve">
    <value>是否希望为你创建 DocumentDB 数据库和集合?</value>
  </data>
  <data name="documentDBOut_databaseName_help" xml:space="preserve">
    <value>这是将写入数据的 DocumentDB 帐户的内部数据库的名称。</value>
  </data>
  <data name="documentDBOut_databaseName_label" xml:space="preserve">
    <value>数据库名称</value>
  </data>
  <data name="documentDBOut_displayName" xml:space="preserve">
    <value>Azure DocumentDB 文档</value>
  </data>
  <data name="documentDBOut_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="documentDBOut_name_label" xml:space="preserve">
    <value>文档参数名称</value>
  </data>
  <data name="httpOut_displayName" xml:space="preserve">
    <value>HTTP</value>
  </data>
  <data name="httpOut_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="httpOut_name_label" xml:space="preserve">
    <value>响应参数名称</value>
  </data>
  <data name="httpTrigger_authLevel_help" xml:space="preserve">
    <value>授权级别控制函数是否需要 API 密钥以及使用哪一个密钥；“函数”使用函数密钥；“管理员”使用主密钥。选中函数时，门户上的“密钥”管理面板中会出现函数密钥和主密钥。对于基于用户的身份验证，请转到 Function App 设置。</value>
  </data>
  <data name="manualTrigger_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="manualTrigger_name_label" xml:space="preserve">
    <value>参数名称</value>
  </data>
  <data name="mobileTableIn_apiKey_help" xml:space="preserve">
    <value>这是指定移动应用的 API 密钥的应用设置名称。&lt;a target='_blank' href='http:go.microsoft.com/fwlink/?LinkId=780568'&gt;详细信息&lt;/a&gt;。</value>
  </data>
  <data name="mobileTableIn_apiKey_label" xml:space="preserve">
    <value>API 密钥查找(可选)</value>
  </data>
  <data name="mobileTableIn_connection_help" xml:space="preserve">
    <value>包含你的移动应用的 URL 的应用设置名称</value>
  </data>
  <data name="mobileTableIn_connection_label" xml:space="preserve">
    <value>移动应用 URL 查找</value>
  </data>
  <data name="mobileTableIn_displayName" xml:space="preserve">
    <value>Azure 移动表记录</value>
  </data>
  <data name="mobileTableIn_id_help" xml:space="preserve">
    <value>这是要检索的记录的 ID。</value>
  </data>
  <data name="mobileTableIn_id_label" xml:space="preserve">
    <value>记录 ID</value>
  </data>
  <data name="mobileTableIn_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="mobileTableIn_name_label" xml:space="preserve">
    <value>记录参数名称</value>
  </data>
  <data name="mobileTableIn_tableName_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="mobileTableIn_tableName_label" xml:space="preserve">
    <value>表单名称</value>
  </data>
  <data name="mobileTableOut_apiKey_help" xml:space="preserve">
    <value>这是指定移动应用的 API 密钥的应用设置名称。&lt;a target='_blank' href='http:go.microsoft.com/fwlink/?LinkId=780568'&gt;详细信息&lt;/a&gt;。</value>
  </data>
  <data name="mobileTableOut_apiKey_label" xml:space="preserve">
    <value>API 密钥查找(可选)</value>
  </data>
  <data name="mobileTableOut_connection_help" xml:space="preserve">
    <value>包含你的移动应用的 URL 的应用设置名称</value>
  </data>
  <data name="mobileTableOut_connection_label" xml:space="preserve">
    <value>移动应用 URL 查找</value>
  </data>
  <data name="mobileTableOut_displayName" xml:space="preserve">
    <value>Azure 移动表记录</value>
  </data>
  <data name="mobileTableOut_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="mobileTableOut_name_label" xml:space="preserve">
    <value>记录参数名称</value>
  </data>
  <data name="mobileTableOut_tableName_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="mobileTableOut_tableName_label" xml:space="preserve">
    <value>表单名称</value>
  </data>
  <data name="notificationHubOut_connection_help" xml:space="preserve">
    <value>包含到你的通知中心命名空间的连接字符串的应用设置名称</value>
  </data>
  <data name="notificationHubOut_connection_label" xml:space="preserve">
    <value>通知中心命名空间连接</value>
  </data>
  <data name="notificationHubOut_displayName" xml:space="preserve">
    <value>Azure 通知中心</value>
  </data>
  <data name="notificationHubOut_hubName_help" xml:space="preserve">
    <value>这是将用于发送推送通知的通知中心的名称。</value>
  </data>
  <data name="notificationHubOut_hubName_label" xml:space="preserve">
    <value>通知中心名称</value>
  </data>
  <data name="notificationHubOut_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="notificationHubOut_name_label" xml:space="preserve">
    <value>通知参数名称</value>
  </data>
  <data name="notificationHubOut_platform_help" xml:space="preserve">
    <value>选择“平台”可发送本机通知。选择“模板”可发送模板通知。</value>
  </data>
  <data name="notificationHubOut_platform_label" xml:space="preserve">
    <value>通知平台</value>
  </data>
  <data name="notificationHubOut_tagExpression_help" xml:space="preserve">
    <value>标记表达式使你在通过通知中心发送推送通知时可以将特定的成套设备/注册作为目标。将其留空可向所有注册的设备发送广播 &lt;a target='_blank' href='http:go.microsoft.com/fwlink/?LinkId=785094'&gt;详细信息&lt;/a&gt;。</value>
  </data>
  <data name="notificationHubOut_tagExpression_label" xml:space="preserve">
    <value>标记表达式(可选)</value>
  </data>
  <data name="notificationHubOut_enableTestSend_help" xml:space="preserve">
    <value>若要获取有关发送通知时遇到的 PNS 错误的详细状态，可将 enableTestSend 设置为 "true" &lt;a target='_blank' href='http:go.microsoft.com/fwlink/?LinkId=832692'&gt;详细信息&lt;/a&gt;。</value>
  </data>
  <data name="notificationHubOut_enableTestSend_label" xml:space="preserve">
    <value>启用测试发送(可选)</value>
  </data>
  <data name="queueTrigger_displayName" xml:space="preserve">
    <value>Azure 队列存储</value>
  </data>
  <data name="sendGrid_displayName" xml:space="preserve">
    <value>SendGrid</value>
  </data>
  <data name="sendGrid_from_help" xml:space="preserve">
    <value>这是发送邮件的电子邮件地址。格式可以为 "user@host.com" 或“显示名称 &lt;user@host.com&gt;”。如果未在此处指定值，则可在代码中指定。</value>
  </data>
  <data name="sendGrid_from_label" xml:space="preserve">
    <value>发件人地址</value>
  </data>
  <data name="sendGrid_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="sendGrid_name_label" xml:space="preserve">
    <value>消息参数名称</value>
  </data>
  <data name="sendGrid_subject_help" xml:space="preserve">
    <value>用于邮件的主题行。如果未在此处提供，则可在代码中指定该值。</value>
  </data>
  <data name="sendGrid_subject_label" xml:space="preserve">
    <value>邮件主题</value>
  </data>
  <data name="sendGrid_text_help" xml:space="preserve">
    <value>用于邮件的文本正文。如果未在此处提供，则可在代码中指定该值。</value>
  </data>
  <data name="sendGrid_text_label" xml:space="preserve">
    <value>邮件文本</value>
  </data>
  <data name="sendGrid_to_help" xml:space="preserve">
    <value>应向其发送邮件的电子邮件地址。格式可以为 "user@host.com" 或“显示名称 &lt;user@host.com&gt;”。如果未在此处提供，则可在代码中指定该值。</value>
  </data>
  <data name="sendGrid_to_label" xml:space="preserve">
    <value>收件地址</value>
  </data>
  <data name="serviceBusOut_accessRights_help" xml:space="preserve">
    <value>服务总线连接字符串的访问权限。如果使用的是没有“管理”权限的连接字符串，则设置为“发送”。</value>
  </data>
  <data name="serviceBusOut_accessRights_label" xml:space="preserve">
    <value>访问权限</value>
  </data>
  <data name="serviceBusOut_connection_help" xml:space="preserve">
    <value>包含你的服务总线连接字符串的应用设置名称。连接字符串必须具有“发送”权限。</value>
  </data>
  <data name="serviceBusOut_connection_label" xml:space="preserve">
    <value>服务总线连接</value>
  </data>
  <data name="serviceBusOut_displayName" xml:space="preserve">
    <value>Azure 服务总线</value>
  </data>
  <data name="serviceBusOut_messageType_help" xml:space="preserve">
    <value>服务总线消息的类型，可以为队列或主题。</value>
  </data>
  <data name="serviceBusOut_messageType_label" xml:space="preserve">
    <value>消息类型</value>
  </data>
  <data name="serviceBusOut_messageType_queueName" xml:space="preserve">
    <value>服务总线队列</value>
  </data>
  <data name="serviceBusOut_messageType_topicName" xml:space="preserve">
    <value>服务总线主题</value>
  </data>
  <data name="serviceBusOut_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="serviceBusOut_name_label" xml:space="preserve">
    <value>消息参数名称</value>
  </data>
  <data name="serviceBusOut_queueName_errorText" xml:space="preserve">
    <value>队列名称必须以字母或数字开头和结尾，并且只能包含字母、数字、连字符、句点和下划线。名称必须介于 1 到 50 个字符之间。</value>
  </data>
  <data name="serviceBusOut_queueName_help" xml:space="preserve">
    <value>将向其发送消息的队列。</value>
  </data>
  <data name="serviceBusOut_queueName_label" xml:space="preserve">
    <value>队列名称</value>
  </data>
  <data name="serviceBusOut_topicName_errorText" xml:space="preserve">
    <value>主题名称必须以字母或数字开头和结尾，并且只能包含字母、数字、连字符、句点和下划线。名称必须介于 1 到 50 个字符之间。</value>
  </data>
  <data name="serviceBusOut_topicName_help" xml:space="preserve">
    <value>将向其发送消息的主题。</value>
  </data>
  <data name="serviceBusOut_topicName_label" xml:space="preserve">
    <value>主题名称</value>
  </data>
  <data name="serviceBusTrigger_accessRights_help" xml:space="preserve">
    <value>服务总线连接字符串的访问权限。如果使用的是没有“管理”权限的连接字符串，则设置为“发送”。</value>
  </data>
  <data name="serviceBusTrigger_accessRights_label" xml:space="preserve">
    <value>访问权限</value>
  </data>
  <data name="serviceBusTrigger_connection_help" xml:space="preserve">
    <value>包含你的服务总线连接字符串的应用设置名称。连接字符串必须具有“侦听”权限。</value>
  </data>
  <data name="serviceBusTrigger_connection_label" xml:space="preserve">
    <value>服务总线连接</value>
  </data>
  <data name="serviceBusTrigger_displayName" xml:space="preserve">
    <value>Azure 服务总线</value>
  </data>
  <data name="serviceBusTrigger_messageType_help" xml:space="preserve">
    <value>服务总线消息的类型，可以为队列或主题。</value>
  </data>
  <data name="serviceBusTrigger_messageType_label" xml:space="preserve">
    <value>消息类型</value>
  </data>
  <data name="serviceBusTrigger_messageType_queueName" xml:space="preserve">
    <value>服务总线队列</value>
  </data>
  <data name="serviceBusTrigger_messageType_topicName" xml:space="preserve">
    <value>服务总线主题</value>
  </data>
  <data name="serviceBusTrigger_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此触发器的名称</value>
  </data>
  <data name="serviceBusTrigger_name_label" xml:space="preserve">
    <value>消息参数名称</value>
  </data>
  <data name="serviceBusTrigger_queueName_errorText" xml:space="preserve">
    <value>队列名称必须以字母或数字开头和结尾，并且只能包含字母、数字、连字符、句点和下划线。名称必须介于 1 到 50 个字符之间。</value>
  </data>
  <data name="serviceBusTrigger_queueName_help" xml:space="preserve">
    <value>将从中读取消息的队列。</value>
  </data>
  <data name="serviceBusTrigger_queueName_label" xml:space="preserve">
    <value>队列名称</value>
  </data>
  <data name="serviceBusTrigger_subscriptionName_errorText" xml:space="preserve">
    <value>订阅名称必须以字母或数字开头和结尾，并且只能包含字母、数字、连字符、句点和下划线。名称必须介于 1 到 50 个字符之间。</value>
  </data>
  <data name="serviceBusTrigger_subscriptionName_help" xml:space="preserve">
    <value>要绑定到的主题内的订阅名称。</value>
  </data>
  <data name="serviceBusTrigger_subscriptionName_label" xml:space="preserve">
    <value>订阅名</value>
  </data>
  <data name="serviceBusTrigger_topicName_errorText" xml:space="preserve">
    <value>主题名称必须以字母或数字开头和结尾，并且只能包含字母、数字、连字符、句点和下划线。名称必须介于 1 到 50 个字符之间。</value>
  </data>
  <data name="serviceBusTrigger_topicName_help" xml:space="preserve">
    <value>将从中读取消息的主题的名称。</value>
  </data>
  <data name="serviceBusTrigger_topicName_label" xml:space="preserve">
    <value>主题名称</value>
  </data>
  <data name="tableIn_displayName" xml:space="preserve">
    <value>Azure 表存储</value>
  </data>
  <data name="tableIn_filter_help" xml:space="preserve">
    <value>用于筛选表查询结果的可选查询表达式。此设置不适用于 C# 函数。</value>
  </data>
  <data name="tableIn_filter_label" xml:space="preserve">
    <value>查询筛选器(可选)</value>
  </data>
  <data name="tableIn_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="tableIn_name_label" xml:space="preserve">
    <value>表参数名称</value>
  </data>
  <data name="tableIn_partitionKey_help" xml:space="preserve">
    <value>表的分区键列的名称。将会返回具有匹配的分区键和行键的记录。如果提供了分区键，也必须要提供行键。</value>
  </data>
  <data name="tableIn_partitionKey_label" xml:space="preserve">
    <value>分区键(可选)</value>
  </data>
  <data name="tableIn_rowKey_help" xml:space="preserve">
    <value>表的分区键列的名称。将会返回具有匹配的分区键和行键的记录。如果提供了分区键，也必须要提供行键。</value>
  </data>
  <data name="tableIn_rowKey_label" xml:space="preserve">
    <value>行键(可选)</value>
  </data>
  <data name="tableIn_tableName_errorText" xml:space="preserve">
    <value>表名称必须为包含 3 到 63 个字符的字母数字字符串，且不能以数字开头。</value>
  </data>
  <data name="tableIn_tableName_help" xml:space="preserve">
    <value>将从中读取数据的存储帐户内的表名称。</value>
  </data>
  <data name="tableIn_tableName_label" xml:space="preserve">
    <value>表单名称</value>
  </data>
  <data name="tableIn_take_help" xml:space="preserve">
    <value>要返回的最大记录数的整数值。根据表内容和筛选器，你可能会收到比这个值更少的记录数。此设置不适用于 C# 函数。</value>
  </data>
  <data name="tableIn_take_label" xml:space="preserve">
    <value>要读取的记录的最大数量(可选)</value>
  </data>
  <data name="tableout_displayName" xml:space="preserve">
    <value>Azure 表存储</value>
  </data>
  <data name="tableout_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="tableout_name_label" xml:space="preserve">
    <value>表参数名称</value>
  </data>
  <data name="table_tableName_errorText" xml:space="preserve">
    <value>表名称必须为包含 3 到 63 个字符的字母数字字符串。不能以数字开头。</value>
  </data>
  <data name="table_tableName_help" xml:space="preserve">
    <value>将向其中写入数据的存储帐户内的表名称。</value>
  </data>
  <data name="table_tableName_label" xml:space="preserve">
    <value>表单名称</value>
  </data>
  <data name="BlobTriggerBatch_description" xml:space="preserve">
    <value>(实验)一个 Batch 函数，每当将 blob 添加到指定容器时它都会运行</value>
  </data>
  <data name="BlobTriggerCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当将 blob 添加到指定容器时它都会运行</value>
  </data>
  <data name="BlobTriggerFSharp_description" xml:space="preserve">
    <value>每当将 blob 添加到指定容器时都会运行的 F# 函数</value>
  </data>
  <data name="BlobTriggerNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当将 blob 添加到指定容器时它都会运行</value>
  </data>
  <data name="CSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当收到 GitHub Webhook 请求时它都会运行</value>
  </data>
  <data name="EmptyBash_description" xml:space="preserve">
    <value>一个空 Bash 函数，没有触发器、输入或输出</value>
  </data>
  <data name="EmptyBatch_description" xml:space="preserve">
    <value>一个空 Batch 函数，没有触发器、输入或输出</value>
  </data>
  <data name="EmptyCSharp_description" xml:space="preserve">
    <value>一个空 C# 函数，没有触发器、输入或输出</value>
  </data>
  <data name="EmptyFSharp_description" xml:space="preserve">
    <value>一个空 F# 函数，没有触发器、输入或输出</value>
  </data>
  <data name="EmptyNodeJS_description" xml:space="preserve">
    <value>一个空 JavaScript 函数，没有触发器、输入或输出</value>
  </data>
  <data name="EmptyPHP_description" xml:space="preserve">
    <value>一个空 PHP 函数，没有触发器、输入或输出</value>
  </data>
  <data name="EmptyPowerShell_description" xml:space="preserve">
    <value>一个空 PowerShell 函数，没有触发器、输入或输出</value>
  </data>
  <data name="EmptyPython_description" xml:space="preserve">
    <value>一个空 Python 函数，没有触发器、输入或输出</value>
  </data>
  <data name="EventHubTriggerCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当事件中心收到一个新事件时它都会运行</value>
  </data>
  <data name="EventHubTriggerFSharp_description" xml:space="preserve">
    <value>每当事件中心收到新事件时都会运行的 F# 函数</value>
  </data>
  <data name="EventHubTriggerNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当事件中心收到一个新事件时它都会运行</value>
  </data>
  <data name="EventHubTriggerPython_description" xml:space="preserve">
    <value>(实验)一个 Python 函数，每当事件中心收到一个新事件时它都会运行</value>
  </data>
  <data name="FaceLocatorCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，它会处理映像并输出平面的边框</value>
  </data>
  <data name="FaceLocatorFSharp_description" xml:space="preserve">
    <value>一个 F# 函数，它会处理映像并输出平面的边框</value>
  </data>
  <data name="FaceLocatorNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，它会处理映像并输出平面的边框</value>
  </data>
  <data name="GenericWebhookCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当收到 Webhook 请求时它都会运行</value>
  </data>
  <data name="GenericWebhookFSharp_description" xml:space="preserve">
    <value>每当收到 Webhook 请求时都会运行的 F# 函数</value>
  </data>
  <data name="GenericWebhookNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当收到 Webhook 请求时它都会运行</value>
  </data>
  <data name="GitHubCommenterNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当收到 GitHub Webhook 请求时它都会运行</value>
  </data>
  <data name="GitHubCommenterFSharp_description" xml:space="preserve">
    <value>每当收到 GitHub Webhook 请求时都会运行的 F# 函数</value>
  </data>
  <data name="GithubWebhookCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当收到 GitHub Webhook 请求时它都会运行</value>
  </data>
  <data name="GithubWebhookFSharp_description" xml:space="preserve">
    <value>每当收到 GitHub Webhook 请求时都会运行的 F# 函数</value>
  </data>
  <data name="GithubWebhookNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当收到 GitHub Webhook 请求时它都会运行</value>
  </data>
  <data name="HttpGETCRUDC_description" xml:space="preserve">
    <value>一个 C# 函数，当它收到 HTTP 请求时会从存储表获取实体</value>
  </data>
  <data name="HttpGETCRUDFSharp_description" xml:space="preserve">
    <value>当收到 HTTP 请求时会从存储表提取实体的 F# 函数</value>
  </data>
  <data name="HttpGETCRUDNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，当它收到 HTTP 请求时会从存储表获取实体</value>
  </data>
  <data name="HttpGETCRUDPHP_description" xml:space="preserve">
    <value>(实验)一个 PHP 函数，当它收到 HTTP 请求时会从存储表提取实体</value>
  </data>
  <data name="HttpPOSTCRUDCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，当它收到 HTTP 请求时会向存储表添加实体</value>
  </data>
  <data name="HttpPOSTCRUDFSharp_description" xml:space="preserve">
    <value>当收到 HTTP 请求时会向存储表添加实体的 F# 函数</value>
  </data>
  <data name="HttpPOSTCRUDNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，当它收到 HTTP 请求时会向存储表添加实体</value>
  </data>
  <data name="HttpPUTCRUDC_description" xml:space="preserve">
    <value>当收到 HTTP 请求时会更新存储表中的实体的 C# 函数</value>
  </data>
  <data name="HttpPUTCRUDFSharp_description" xml:space="preserve">
    <value>当收到 HTTP 请求时会更新存储表中的实体的 F# 函数</value>
  </data>
  <data name="HttpTriggerBatch_description" xml:space="preserve">
    <value>(实验)一个 Batch 函数，每当它收到 HTTP 请求时都会运行</value>
  </data>
  <data name="HttpTriggerCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当它收到 HTTP 请求时都会运行</value>
  </data>
  <data name="HttpTriggerFSharp_description" xml:space="preserve">
    <value>每当收到 HTTP 请求时都会运行的 F# 函数</value>
  </data>
  <data name="HttpTriggerNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当它收到 HTTP 请求时都会运行</value>
  </data>
  <data name="HttpTriggerPowerShell_description" xml:space="preserve">
    <value>(预览)一个 PowerShell 函数，每当它收到 HTTP 请求时都会运行</value>
  </data>
  <data name="HttpTriggerPython_description" xml:space="preserve">
    <value>(试验)一个 Python 3 函数，它将在接收 HTTP 请求的任何时候运行</value>
  </data>
  <data name="ImageResizerCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当将 blob 添加到指定容器时它都会创建已调整大小的映像</value>
  </data>
  <data name="ImageResizerFSharp_description" xml:space="preserve">
    <value>每当将 blob 添加到指定容器时都会创建已调整大小的映像的 F# 函数</value>
  </data>
  <data name="ManualTriggerCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，通过门户“运行”按钮手动触发</value>
  </data>
  <data name="ManualTriggerFSharp_description" xml:space="preserve">
    <value>通过门户“运行”按钮手动触发的 F# 函数</value>
  </data>
  <data name="ManualTriggerNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，通过门户“运行”按钮手动触发</value>
  </data>
  <data name="QueueTriggerBash_description" xml:space="preserve">
    <value>(实验)一个 bash 函数，每当将消息添加到指定的 Azure 队列存储时它都会运行</value>
  </data>
  <data name="QueueTriggerBatch_description" xml:space="preserve">
    <value>(实验)一个 Batch 函数，每当将消息添加到指定的 Azure 队列存储时它都会运行</value>
  </data>
  <data name="QueueTriggerCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当将消息添加到指定的 Azure 队列存储时它都会运行</value>
  </data>
  <data name="QueueTriggerFSharp_description" xml:space="preserve">
    <value>一个 F# 函数，每当将消息添加到指定的 Azure 队列存储时它都会运行</value>
  </data>
  <data name="QueueTriggerNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当将消息添加到指定的 Azure 队列存储时它都会运行</value>
  </data>
  <data name="QueueTriggerPHP_description" xml:space="preserve">
    <value>(实验)一个 PHP 函数，每当将消息添加到指定的 Azure 队列存储时它都会运行</value>
  </data>
  <data name="QueueTriggerPowerShell_description" xml:space="preserve">
    <value>(预览)一个 PowerShell 函数，每当将消息添加到指定的 Azure 队列存储时它都会运行</value>
  </data>
  <data name="QueueTriggerPython_description" xml:space="preserve">
    <value>(实验)一个 Python 函数，每当将消息添加到指定的 Azure 队列存储时它都会运行</value>
  </data>
  <data name="SaasFileTriggerBatch_description" xml:space="preserve">
    <value>(实验)一个 Batch 函数，每当将文件添加到外部文件提供程序时它都会运行。</value>
  </data>
  <data name="SaasFileTriggerCSharp_description" xml:space="preserve">
    <value>(预览)一个 C# 函数，每当将文件添加到外部文件提供程序时它都会运行。</value>
  </data>
  <data name="SaasFileTriggerFSharp_description" xml:space="preserve">
    <value>(预览)一个 F# 函数，每当将文件添加到外部文件提供程序时它都会运行。</value>
  </data>
  <data name="SaasFileTriggerNodeJS_description" xml:space="preserve">
    <value>(预览)一个 JavaScript 函数，每当将文件添加到外部文件提供程序时它都会运行。</value>
  </data>
  <data name="SaasFileTokenNodeJS_description" xml:space="preserve">
    <value>(预览)一个 JavaScript 函数，每当将文件添加到外部文件提供程序时它都会运行。</value>
  </data>
  <data name="SaasTableCSharp_description" xml:space="preserve">
    <value>(实验)一个 C# 函数，每当它收到 HTTP 请求时都将从外部表中提取实体。</value>
  </data>
  <data name="SaasTableFSharp_description" xml:space="preserve">
    <value>(实验)一个 F# 函数，每当它收到 HTTP 请求时都将从外部表中提取实体。</value>
  </data>
  <data name="SasTokenFSharp_description" xml:space="preserve">
    <value>为给定容器和 blob 名称的 Azure 存储生成 SAS 令牌的 F# 函数。</value>
  </data>
  <data name="SendGridCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当将新项添加到特定的队列时它都会发送一封确认电子邮件</value>
  </data>
  <data name="SendGridFSharp_description" xml:space="preserve">
    <value>一个 F# 函数，每当将新项添加到特定的队列时它都会发送一封确认电子邮件</value>
  </data>
  <data name="SendGridNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当将新项添加到特定的队列时它都会发送一封确认电子邮件</value>
  </data>
  <data name="ServiceBusQueueTriggerCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，每当将消息添加到指定的服务总线队列时它都会运行</value>
  </data>
  <data name="ServiceBusQueueTriggerFSharp_description" xml:space="preserve">
    <value>每当将消息添加到指定服务总线队列时都会运行的 F# 函数</value>
  </data>
  <data name="ServiceBusQueueTriggerNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当将消息添加到指定的服务总线队列时它都会运行</value>
  </data>
  <data name="ServiceBusTopicTriggerFSharp_description" xml:space="preserve">
    <value>每当将消息添加到指定服务总线主题时都会运行的 F# 函数</value>
  </data>
  <data name="ServiceBusTopicTriggerNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当将消息添加到指定的服务总线主题时它都会运行</value>
  </data>
  <data name="TimerTriggerCSharp_description" xml:space="preserve">
    <value>将在指定的计划上运行的 C# 函数</value>
  </data>
  <data name="TimerTriggerFSharp_description" xml:space="preserve">
    <value>将按指定计划运行的 F# 函数</value>
  </data>
  <data name="TimerTriggerNodeJS_description" xml:space="preserve">
    <value>将在指定的计划上运行的 JavaScript 函数</value>
  </data>
  <data name="TimerTriggerPowerShell_description" xml:space="preserve">
    <value>(预览)一个 PowerShell 函数，它将按指定计划运行</value>
  </data>
  <data name="timerTrigger_schedule_errorText" xml:space="preserve">
    <value>无效的 Cron 表达式。请查阅&lt;a target='_blank' href='https://azure.microsoft.com/en-us/documentation/articles/functions-bindings-timer/'&gt;文档&lt;/a&gt;以了解详细信息。</value>
  </data>
  <data name="twilioSms_accountsid_help" xml:space="preserve">
    <value>包含你的 Twilio 帐户 SID 的应用设置的名称</value>
  </data>
  <data name="twilioSms_accountsid_label" xml:space="preserve">
    <value>帐户 SID 设置</value>
  </data>
  <data name="twilioSms_authtoken_help" xml:space="preserve">
    <value>包含你的 Twilio 身份验证令牌的应用设置的名称</value>
  </data>
  <data name="twilioSms_authtoken_label" xml:space="preserve">
    <value>身份验证令牌设置</value>
  </data>
  <data name="twilioSms_body_help" xml:space="preserve">
    <value>用于邮件的文本正文。如果未在此处提供，则可在代码中指定该值。</value>
  </data>
  <data name="twilioSms_body_label" xml:space="preserve">
    <value>消息文本</value>
  </data>
  <data name="twilioSms_displayName" xml:space="preserve">
    <value>Twilio 短信</value>
  </data>
  <data name="twilioSms_from_help" xml:space="preserve">
    <value>应从其发送消息的 Twilio 电话号码。如果此处未提供，则可在代码中指定该值。</value>
  </data>
  <data name="twilioSms_from_label" xml:space="preserve">
    <value>发送号码</value>
  </data>
  <data name="twilioSms_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="twilioSms_name_label" xml:space="preserve">
    <value>消息参数名称</value>
  </data>
  <data name="twilioSms_to_help" xml:space="preserve">
    <value>应向其发送消息的电话号码。如果此处未提供，则可在代码中指定该值。</value>
  </data>
  <data name="twilioSms_to_label" xml:space="preserve">
    <value>接收号码</value>
  </data>
  <data name="eventHubTrigger_consumerGroup_errorText" xml:space="preserve">
    <value>使用者组必须以字母或数字开头和结尾，并且只能包含字母、数字、连字符、句点和下划线。还允许使用 $Default 组。名称必须介于 1 到 50 个字符之间。</value>
  </data>
  <data name="documentDB_displayName" xml:space="preserve">
    <value>Azure DocumentDB 文档</value>
  </data>
  <data name="sendGrid_apiKey_help" xml:space="preserve">
    <value>SendGrid 开发人员 API 密钥</value>
  </data>
  <data name="sendGrid_apiKey_label" xml:space="preserve">
    <value>SendGrid API 密钥</value>
  </data>
  <data name="bot_botId_help" xml:space="preserve">
    <value>这是在创建消息并将其发送到 bot 时，活动的 From 属性所使用的 ID，这将填充已发送活动的 ChannelAccount.Id。</value>
  </data>
  <data name="bot_botId_label" xml:space="preserve">
    <value>发件人 ID</value>
  </data>
  <data name="bot_in_displayName" xml:space="preserve">
    <value>Bot Framework (预览版)</value>
  </data>
  <data name="bot_out_displayName" xml:space="preserve">
    <value>Bot Framework (预览版)</value>
  </data>
  <data name="bot_in_secret_help" xml:space="preserve">
    <value>Direct Line 键可从 Bot Framework 门户的 Direct Line 通道配置页面生成；将此字段留空将在应用程序设置 "AzureWebJobsBotFrameworkDirectLineSecret" 中查找值</value>
  </data>
  <data name="bot_in_secret_label" xml:space="preserve">
    <value>Direct Line 键</value>
  </data>
  <data name="bot_out_secret_help" xml:space="preserve">
    <value>Direct Line 键可从 Bot Framework 门户的 Direct Line 通道配置页面生成；将此字段留空将在应用程序设置 "AzureWebJobsBotFrameworkDirectLineSecret" 中查找值</value>

  </data>
  <data name="bot_out_secret_label" xml:space="preserve">
    <value>Direct Line 键</value>
  </data>
  <data name="bot_in_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="bot_in_name_label" xml:space="preserve">
    <value>Bot 参数名称</value>
  </data>
  <data name="bot_out_name_help" xml:space="preserve">
    <value>用于在你的代码中标识此绑定的名称</value>
  </data>
  <data name="bot_out_name_label" xml:space="preserve">
    <value>Bot 参数名称</value>
  </data>
  <data name="ScheduledMailCSharp_description" xml:space="preserve">
    <value>(预览)将定期发送电子邮件的 C# 函数</value>
  </data>
  <data name="documentDBIn_sqlQuery_help" xml:space="preserve">
    <value>这是用于检索文档集的可选 DocumentDB SQL 查询。如果既未指定 SQL 查询也未指定 ID，则返回集合中的所有文档。</value>
  </data>
  <data name="documentDBIn_sqlQuery_label" xml:space="preserve">
    <value>SQL 查询 (可选)</value>
  </data>
  <data name="eventHubTrigger_cardinality_help" xml:space="preserve">
    <value>触发器输入的基数。如果输入为一条单独的消息，则选择“1 条”，如果输入为一系列消息，则选择“多条”。未指定时默认选择“1 条”。</value>
  </data>
  <data name="HttpTriggerCSharpWithParameters_description" xml:space="preserve">
    <value>一个 C# 函数，每当它收到 HTTP 请求时都会运行</value>
  </data>
  <data name="eventHubTrigger_cardinality_label" xml:space="preserve">
    <value>事件中心基数</value>
  </data>
  <data name="HttpTriggerWithParametersNodeJS_description" xml:space="preserve">
    <value>一个 JavaScript 函数，每当它收到 HTTP 请求时都会运行</value>
  </data>
  <data name="cdsWebHookCSharp_description" xml:space="preserve">
    <value>(实验)可使用 CDS SDK 调入 CDS 环境的 CDS 函数。</value>
  </data>
  <data name="cdsTemplate_warningNotConfigured" xml:space="preserve">
    <value>此模板需要针对 Function App 的 AAD 配置。模板需要下列权限:

Common Data Service - 访问 Common Data Service
Microsoft Azure Service Management API - 以组织用户身份访问 Azure Service Management (预览)。</value>
  </data>
  <data name="temp_category_monitoring" xml:space="preserve">
    <value>监视</value>
  </data>
  <data name="AppInsightsHttpAvailability_name" xml:space="preserve">
    <value>AppInsights Http 可用性</value>
  </data>
  <data name="AppInsightsHttpAvailabilityCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，它使用 Application Insights 监视任何 Web 应用的可用性和响应能力</value>
  </data>
  <data name="AppInsightsRealtimePowerBI_name" xml:space="preserve">
    <value>AppInsights 实时 Power BI</value>
  </data>
  <data name="AppInsightsRealtimePowerBICSharp_description" xml:space="preserve">
    <value>将实时可用性数据从 Application Insights 推送到 Power BI 的 C# 函数</value>
  </data>
  <data name="AppInsightsScheduledAnalytics_name" xml:space="preserve">
    <value>AppInsights 计划分析</value>
  </data>
  <data name="AppInsightsScheduledAnalyticsCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，它从借助 Application Insights 执行应用遥测深度分析中获得指标</value>
  </data>
  <data name="AppInsightsScheduledDigest_name" xml:space="preserve">
    <value>AppInsights 计划摘要</value>
  </data>
  <data name="AppInsightsScheduledDigestCSharp_description" xml:space="preserve">
    <value>一个 C# 函数，它通过电子邮件发送每日 Application Insights 遥测报表</value>
  </data>
  <data name="HttpPOST(CRUD)Queue-FSharp_description" xml:space="preserve">
    <value>将数据推送到队列以接收 Http Post 的 F# 函数。</value>
  </data>
</root>